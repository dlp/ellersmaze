%!PS-Adobe-3.0

%(util.ps) run


(Begin\n) print

/N 10 def

seed dup = srand

/cointoss { % -- => bool
    rand 2 mod 0 eq
} def

/border-right  N array def
/border-bottom N array def
/next N array def
/prev N array def

/clear-borders
{
    N {false} repeat border-right  astore pop
    N {false} repeat border-bottom astore pop
} def

/set-border-bottom { % i => --
    border-bottom exch true put
} def

/set-border-right { % i => --
    border-right  exch true put
} def

/print-top {
    ( ) print
    N {(___ ) print} repeat
    (\n) print
} def


/init-sets {
    0 1 N 1 sub { % for 0 .. N-1
        dup % we need the control variable twice
        next exch dup put
        prev exch dup put
    } for
} def

/set-equal % u v => bool
{
    2 dict
    begin
        /v exch def
        /u exch def
        % u.next == v && u == v.prev
        next u get  v  eq
        prev v get  u  eq
        and
    end
} def


/set-islast { % u => bool
    dup % u u
    next exch % u next u
    get % u nu
    ge
} def

/set-remove % u => --
{
    1 dict
    begin
        /u exch def
        % u.prev.next = u.next
        prev u get  % load u.prev
        next exch   % prepare .next
        next u get  % load u.next
        put
        % u.next.prev = u.prev
        next u get
        prev exch
        prev u get
        put
        % u.next = u
        next u u put
        % u.prev = u
        prev u u put
    end
} def


/set-join % u v => --
{
    2 dict
    begin
        /v exch def
        /u exch def

        % u.next.prev = v.prev
        next u get  % load u.next
        prev exch   % prepare .prev
        prev v get  % load v.prev
        put
        % v.prev.next = u.next
        prev v get  % load v.prev
        next exch   % prepare .next
        next u get  % load u.next
        put

        next u v put % u.next = v
        prev v u put % v.prev = u
    end
} def

% print a maze row based on borders
/print-row { % -- => --
    (|) print % leftmost border
    0 1
    N 1 sub
    dup set-border-right % unconditonally set rightmost border
    { % for 0 .. N-1
        dup % we need the control variable twice
        border-bottom exch get {(___)} {(   )} ifelse print
        border-right  exch get {(|)  } {( )  } ifelse print
    } for
    (\n) print
} def

% debugging aid
/show-links {
    (Links:\n) print
    (prev ) print prev ==
    (next ) print next ==
} def

% debugging aid
% assume u,y are defined
/show-pair {
    [ (pair: ) u  v ] { = } forall
} def


% depending on chance, set right border of u or join sets of u and v
/set-border-or-join { % u v => --
    cointoss { pop set-border-right } { set-join } ifelse
} def

/make-border-right { % u => --
    /u exch def
    u N 1 sub lt {
        /v u 1 add def
        u v set-equal { u set-border-right } {
            u v set-border-or-join
        } ifelse
        v make-border-right % recurse
    }
    if
} def


/last-row { % u => --
    /u exch def
    u set-border-bottom
    u N 1 sub lt {
        /v u 1 add def
        u v set-equal { u set-border-right } {
            u v set-join % in last row we always join
        } ifelse
        v last-row % recurse
    } if
} def

% ary[u] := ary[u.prev]
/assign-from-prev { % ary u => --
    2 copy    % ary u ary u
    prev exch % ary u ary prev u
    get get put
} def

/make-border-bottom { % ary u => --
    /u exch def
    /vertical-passages exch def

    vertical-passages u assign-from-prev

    u set-islast {
        % if u has already vertical passages
        vertical-passages u get {
            cointoss {
                u set-border-bottom
                u set-remove
            } if
        } if
    } {
        % can toss a coin
        cointoss
        { u set-border-bottom u set-remove }
        { vertical-passages u true put }
        ifelse
    } ifelse

    u N 1 sub lt { vertical-passages u 1 add make-border-bottom } if
} def


init-sets
print-top
clear-borders

10 {

    0 make-border-right

    % initial array for vertical-passages
    [ N {false} repeat ] 0 make-border-bottom

    print-row
    clear-borders
} repeat

0 last-row
print-row
pstack % should be empty
(End\n) print
%showpage
quit










% A5 page dimensions in mm
/width 148 mm def
/height 210 mm def
/margin 5 mm def

% draw a black border around the page
/draw-border
  { gsave
    0 0 width height rectstroke
    grestore
  } def


/circle-fill-color % stack: - => -
  {
    %205 210 216 setrgbcolor255
    16#f7f6bb setrgbcolorhex
  } def

/circle-stroke-color % stack: - => -
  { 0.1 setgray } def

/draw-circle % stack: x y r => -
  { gsave
      circle
      gsave circle-fill-color fill grestore
      circle-stroke-color 1.0 setlinewidth stroke
    grestore
  } def


% x1 y1 ... bottom left corner
% x2 y2 ... top right corner
% nx ny ... number of cirles horizontally resp. vertically
/draw-circle-array % stack: x1 y1 x2 y2 nx ny => -
  {
    12 dict
    begin
      /ny exch def
      /nx exch def
      % x1 y1 x2 y2
      2 index sub ny div /dy exch def % dy = (y2-y1)/ny
      % x1 y1 x2
      2 index sub nx div /dx exch def % dx = (x2-x1)/nx
      /y1 exch def
      /x1 exch def
      /r dx dy min 0.4 mul def % r = 0.5*0.8 * min(dx, dy)
      /r 6 mm def

      % center of i-th circle
      % mz_i = z1 + dz (0.5 + i)
      /mx_i % stack: i => mx_i
        { 0.5 add dx mul x1 add } def
      /my_i % stack: i => my_i
        { 0.5 add dy mul y1 add } def

      % print a row of circles
      /draw-circle-row % stack: my => my
        { % 0 .. nx-1
          0 1 nx 1 sub { mx_i 2dup r draw-circle } for
        } def

      % print rows:
      % 0 .. ny-1
      0 1 ny 1 sub { my_i draw-circle-row pop } for
    end
  } def


% Print "Name: _______" at baseline h
/name-line % stack: h => -
  { 1 dict
    begin
      /baseline exch def
      gsave
        margin baseline
        moveto
        /ComicSansMS findfont
        24 scalefont setfont
        (Name:) show
        3 mm -2 mm rmoveto
        width margin sub
        baseline -2 mm add
        lineto
        stroke
      grestore
    end
  } def


% scale whole system for mm units
% (NB: won't work as desired as also the linewidth is scaled)
%/scalefactor 1 mm def
%scalefactor dup scale

% move away from border / add page margin
25 mm dup translate

% A5 => A6
0.7063 dup scale

draw-border

% draw circles field in bottom half
margin dup
width margin sub
height 0.5 mul margin sub
10 6 draw-circle-array


% title with shadow
/ComicSansMS-Bold findfont
40 scalefont setfont
width 2 div
height 20 mm sub
moveto
(Sammelpass) center-text
16#ff6600 setrgbcolorhex
1.7 mm text-shadowed-outlined


% name line at (height - 40 mm)
0.0 setgray
height 38 mm sub name-line

% rectangle for ad/toy sticker
gsave
margin
height 0.5 mul 2 mm add
width margin 2 mul sub
height 0.5 mul 44 mm sub
4 copy
gsave 0.95 setgray rectfill grestore
rectstroke
grestore


/ComicSansMS findfont
18 scalefont setfont
(\(Wunsch hier aufkleben\))
dup stringwidth pop
width exch sub 2 div
height 0.65 mul
moveto
show

showpage
quit
